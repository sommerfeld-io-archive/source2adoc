= Global Requirements and Solution Strategy
Sebastian Sommerfeld <sebastian@sommerfeld.io>

Contained within this AsciiDoc page is a compilation of the project's scope and global conditions for `source2adoc`. Discover concise summaries detailing discussions on project objectives and methodologies, providing a comprehensive overview of the project's parameters.

== Global Requirements
This section outlines the global requirements for the `source2adoc` project, which aims to generate AsciiDoc documentation based on inline comments from source code files.

=== Project Overview
The `source2adoc` project is tasked with automatically generating AsciiDoc documentation from inline comments found within source code files. The application should support multiple source code languages, including bash, YAML, Vagrantfile, Dockerfile, Makefile, and Ruby. Comments in these files will be marked using the hash-symbol (`#`).

=== Command Line Parameter
The application must accept a command line parameter to specify the source code language to be considered. Only one option is allowed per run. To generate AsciiDoc documentation for multiple languages, the application must be executed multiple times with different language settings.

=== Output Location
Generated AsciiDoc files should be placed into an Antora module named `source2adoc`. It is crucial not to delete the entire module and regenerate it from scratch with each application run, as this would prevent running the application multiple times for different languages.

=== Initial Documentation Scope
Initially, the application will only consider code comments acting as header documentation for entire files. Documentation blocks for classes and functions may be considered in future iterations.

=== File Path Preservation
When generating documentation into the Antora module, the file path should be preserved. For instance, the source code file `src/main/Dockerfile` should result in the AsciiDoc file `docs/modules/source2adoc/pages/src/main/Dockerfile.adoc` (with `docs` being the root folder of the antora component).

=== Antora Component Root Folder
The root folder of the Antora component should be changeable via a command line parameter. When the parameter is empty, `docs` will serve as the fallback root folder.

=== File Metadata
The caption of the AsciiDoc file should automatically be set from the source code file's name. Additionally, the path of the source code file and the author (if specified within the code file) should be included in the generated AsciiDoc file. The actual text of the header docs should be rendered into the AsciiDoc file as well. This text will not be translated any further, it is taken as is, thus allowing to write AsciiDoc directly into the source code docs.

=== Comment Style
The code comment style should resemble Javadoc but use the hash-symbol (`#`) as the marker for commented lines. That means the marker for metadata should be similar to Javadoc (e.g. @author, @since, ... but not all of them - see https://en.wikipedia.org/wiki/Javadoc). `@see` should generate an xref, @link should generate a static link

=== Dedicated Docker Image and Website
A dedicated Docker image should be generated for hosting the project's documentation website. This image will contain a website generated with Antora and should be published as `source2adoc.sommerfeld.io`. The GitHub project for hosting this website should be named `source2adoc-website`.

DockerHub serves as our only artifact repository for storing and distributing all images related to this app.

== Global Solution Strategy
This section outlines the global solution strategy for the `source2adoc` project, focusing on development, tooling, deployment, and support considerations.

=== Everything as Code
We embrace treating as much as possible as code, incorporating best practices from software development in every aspect of our work. We prioritize utilizing technologies and tools that allow us to leverage version control and adhere to established development practices like branching and code reviews. This applies to source code, infrastructure code, utility scripts and basically everything that can be depicted as some sort of code.

When it comes to configuration management, we opt for approaches that align with software development principles. If there are multiple ways to apply a configuration, such as through a web UI or an API, we prioritize the API method. This preference is due to its reproducibility, (hopefully) idempotency and potential for automation, ensuring consistency and facilitating efficient management of configurations.

By treating various aspects of our work as code, we can leverage the benefits of version control, automation, and reproducibility.

=== Test Driven Development
We follow Test-Driven Development (TDD) principles, using TDD to design our systems.

=== Version Control
We make all changes to code, test, infrastructure, configuration, and ultimately production via version control.

Version control extends beyond just managing code repositories like Git. It encompasses a broader scope that includes controlling the versions of tools and third-party software utilized within our environments. By actively managing these dependencies, we ensure that our software remains stable, consistent, and immune to uncontrolled changes originating from external sources.

We employ version control to manage and track changes made to our production systems, ensuring that modifications are controlled, traceable, and reversible.

By extending version control to encompass the management of tools, third-party software and production environment, we maintain a firm grip on the external factors that can impact our software development and our runtime environments. This approach allows us to minimize the risk of uncontrolled changes.

=== Commit Messages
Read something about link:https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[Git commit messages].

=== Trunk-Based Development
We follow a trunk-based development approach, which means that we primarily focus our development efforts on the main branch of our repository. This approach encourages frequent and continuous integration of code changes directly into the main branch, allowing us to avoid long-lived feature branches and promote a fast-paced development cycle. We still rely on branching and Pull Requests, but our branches do not live for longer than one day (more on that in the coming sections).

The `main` branch represents the releasable state of the software. It serves as the mainline branch from which stable releases are made.

Any branch other than main is considered a short-lived branch. These branches are used for feature development, bug fixing, and any other updates. There are no specific naming conventions for these branches. These branches do not live for longer than one day.

Git tags are always created from the main branch, ensuring that they represent stable and release-worthy versions of the software. The creation of tags is done exclusively through our deployment pipeline, ensuring consistent and reproducible release processes.

Each developer is streaming small commits either directly into the main branch with a pre-integration step of running the build first (which must pass) or commits into short-lived branches and flows through Pull-Request style code-review and build automation before merging into main.

Basically we follow most recommendations from link:https://trunkbaseddevelopment.com[trunkbaseddevelopment.com].

=== Continuous Integration
We integrate code changes from all developers at least once per day. This frequent integration ensures that our software is thoroughly tested and checked with everyone's changes on a daily basis.

We work with short lived (feature) branches. But we won't hide work on separate branches for longer than a working day before integrating them together.

We don't merge the `main` branch into our feature branches to make them live longer! This is not a way to integrate everyone's changes into a single source of truth and prevents us from determining the releasability of our software.

We grow our code incrementally, making frequent small changes to our code - leaving our code in a working state after each small change.

We get feedback on the quality of our work after every small change through the use of automated tests in pipelines.

=== Automated tests determine the releasability
We automate almost everything in our pipeline, and have enough automated testing to in place to validate and release our changes without dependence on manual regression testing, or approval QA and approval processes.

Manual tests are not forbidden. But since they only make us feel better and more save instead of providing a real judgement on the releasability of our software, the make-it-or-break-it desicion always comes from our pipeline.

When we identify manual tests that are performed repeatedly, we actively work on transforming them into automated tests and integrate them into our pipelines.

=== Keep the software always in a releasable state
While we may not release our software daily, our goal is to have the capability to release changes every day if required. That means we aim to ship a release-candidate at least once per day. To achieve this goal we have to keep our software in a releaseable state all the time!

=== Releases and Deployments always are done through a pipeline
We deploy our changes into production, or any test environment, "at the touch of a button" at most. The goal is to trigger everything from a push to the `main` branch (either directly or through a Pull Request).

This means that all deployments to any test environment, whether it's a software version to some test environment or to production or a Docker image to DockerHub or any other kind of deployment, are carried out automatically via our deployment pipeline.

This pipeline includes all steps and tests that are sufficient to determine the releasability of our software. When a change has completed its transit through the pipeline, there is no more work to do for the software to be released into production other than (at most) triggering the release itself. Deployments are never done manually!

=== Semantic Versioning for our Releases
At our organization, we adhere to link:https://semver.org[Semantic Versioning (SemVer)] principles when releasing artifacts. This means that we follow a structured versioning format, consisting of major, minor, and patch numbers, to indicate changes and updates in our software. Unstable versions are marked as Alpha or Beta version.

Key definitions of Semantic Versioning:

* A normal version number must take the form `major.minor.bugfix` in non-negative integers, and must not contain leading zeroes. Each element must increase numerically. For instance: `1.9.0` -> `1.10.0` -> `1.11.0`.
* Once a versioned package has been released, the contents of that version must not be modified. Any modifications must be released as a new version.
* Major version zero (`0.x.x`)` is for initial development. Anything MAYmay change at any time. The public API should not be considered stable.
* Version `1.0.0` defines the initial public API.
* Patch version (`x.x.patch`) must be incremented if only backward compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.
* Minor version (`x.minor.x`) must be incremented if new, backward compatible functionality is introduced to the public API. It must be incremented if any public API functionality is marked as deprecated. It may be incremented if substantial new functionality or improvements are introduced within the private code. It may include patch level changes. Patch version must be reset to 0 when minor version is incremented.
* Major version (`major.x.x`) must be incremented if any backward incompatible changes are introduced to the public API. It may also include minor and patch level changes. Patch and minor versions must be reset to 0 when major version is incremented.
* A pre-release version may be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: `1.0.0-alpha.0`, `1.0.0-beta.0`.

Our Git tags always include a leading "v" before the version number.

=== Docker Tag Strategy
The Docker tag strategy follows Semantic Versioning for our Releases.

=== Artifacts are immutable
We are validating the delivered artifact with the pipeline. It is built once and deployed to all environments. A common anti-pattern is building an artifact for each environment. Each build is a possibility to introduce unintended changes. By promoting a single artifact through the stages we ensure that the deployed artifact is exactly the one that was tested.

=== User Stories
We want requirements to define small focused needs rather than vast vague projects. We use user stories to describe our requirements. We try to finish a user story within a couple of days at most. We need to keep in mind, that we integrate our changes daily, so we must design our user stories accordingly.

If we can't think of user need in terms of a story, we don't understand what our software is meant to achieve yet. If we can't think of an example, that would demonstrate that the need is fullfilled, we don't really understand the problem (domain) yet.

=== Application Language and Build Tool
The application will be developed using Kotlin and built with Maven. The familiarity of the development team with Maven dictates its usage for now, although the possibility of re-evaluating Gradle in the future remains open.

=== Packaging and Distribution
The application will be packaged and published solely as a Docker image. No other package format will be supported.

=== Development Environment
Development will primarily occur on Ubuntu workstations.

=== Integrated Development Environment (IDE)
The IDE of choice for development is Visual Studio Code (VSCode). Despite IntelliJ IDEA's superior Kotlin support, VSCode is preferred due to its support for DevContainers (an essential requirement) and GitHub Copilot.

=== Source Code Hosting
All `source2adoc` projects will be hosted on GitHub.

=== Pipelines and Workflows
The pipeline and workflow engine of choice is GitHub Actions.

=== Deployment of Documentation Website
The deployment strategy for the "source2adoc.sommerfeld.io" website is still under consideration. While a container running in a public cloud provider like AWS, Google Cloud, Linode, or BlueOcean is preferred, uploading the website to a classic web hosting solution via FTP might serve as a simpler (initial) solution.

=== Development Support
Development efforts will be supported by GitHub Copilot, with the potential for heavy reliance on this AI-assistant as its usefulness is validated over time.

=== Task and Todo Tracking
All task and todo tracking will be done through a GitHub project.

== Contribute to our Projects
We're thrilled that you'd like to contribute to this project. You can do this by submitting a pull request.

. Fork and clone the repository
. Create a new branch: git checkout -b my-branch-name
. Make your changes and include tests (preferably by using TDD)
. Make sure the tests pass
. Format code and build artifacts
. Push to your fork and submit a pull request
. Pat your self on the back and wait for your pull request to be reviewed and merged

Here are a few things you can do that will increase the likelihood of your pull request being accepted:

. Write tests
. Make sure the documentation (docs folder) and any other relevant documentation are kept up-to-date
. We try to follow SemVer v2.0.0 so randomly breaking public APIs is not an option
. Keep your change as focused as possible - If there are multiple changes you would like to make that are not dependent upon each other, consider submitting them as separate pull requests
. Write a link:https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[good commit message]

== Follow-up To-Dos
This section outlines the follow-up tasks to be addressed sometime in the future for the `source2adoc` project.

=== License Decision
A decision regarding the project's license needs to be made. The project will be open source and is intended to remain open source indefinitely. However, it is essential to ensure that anyone who forks the project maintains a reference to the original author and the original project including links to the projects GitHub repository and  the documentation website (which is https://source2adoc.sommerfeld.io).

=== Tutorial
A tutorial on how to generate an Antora website with the contents generated by `source2adoc` needs to be written. This tutorial will provide step-by-step instructions on setting up and configuring Antora and how to use the generated AsciiDoc files as one of its content sources.

=== Logo
Generate a logo for this project with some image generating AI. The logo should work for (probably) the dark-mode documentation website and when printed on white paper.

=== Deprecation Mark for `source2docs`
Mark the `source2docs` image from the link:https://github.com/sommerfeld-io/docker-images[sommerfeld-io/docker-images] project as deprecated and remove from all project. Replace with this `source2adoc` project and remove `source2docs` from its project and from DockerHub.
